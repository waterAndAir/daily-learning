### HTTP 

#### HTTP 1.1

#### HTTP 2.0
- 头部压缩(HPACK):在两端建立头部 key-value 的索引表，传输的时候，对相同的头只发送索引
- 虚拟的流：将一个TCP连接切分成多个流，每个流有自己的ID，且可以向对方发送消息，流式一个虚拟的通道，有优先级
- 二进制格式：将消息分为更小的消息和帧，并采用二进制编码，Header 帧用于传输 Header 并开启一个新的流，Data 帧传输正文实体，多个Data属于同一个流  

HTTP 2.0 通过上述方式将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。  

而实际上，HTTP2.0其实只是将三个请求变成三个流，将数据分成帧，乱序发送到一个TCP连接中。所以依然受到 TCP 严格顺序的限制，当前面stream 2的帧没有收到，后面stream 1的帧也会因此阻塞。

#### QUIC
QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。
##### 自定义连接机制
tcp 通过源IP，源端口，目标IP，目标端口 标识一个连接，其中一个元素变了，就需要重新三次握手。  、
QUIC 基于UDP，设计了根据一个 64 位随机数作为连接标识，当IP或端口变化时，只要ID不变，就不需要重新建立连接

##### 自定义重传机制
TCP 通过序号和确认序号，保证顺序问题和丢包问题。  

QUIC 的每个数据包也有一个序列号，但是是递增的，这样就可以准确的计算 rtt 时间，通过 offset 判断是否是同一个数据包

##### 无阻塞多路复用
同HTTP 2.0一样，同一条QUIC连接上可以创建多个stream，来发送多个 HTTP 请求。但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重传，但是stream3的包无需等待，就可以发给用户。

##### 自定义流量控制
不但在一个连接上控制窗口，还在一个连接中的每个stream控制窗口。

TCP 中应答了一个包，就表示它之前的包应答过了，所以在窗口中，即使后面的包以及接收到了，也只能在窗口中缓存而不进行应答，这样就有可能因为前面的包丢失而导致后面已经接收包超时发起重发，浪费宽带。    

QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可
#### HTTP 3.0

#### HTTPS

#### DNS
##### DNS 解析过程
- 客户端向本地DNS服务器发起一个 DNS 请求查询域名对应的IP地址。 如果IP是通过DHCP配置的，本地DNS 服务器就是网络服务商的某个机器
- 本地DNS在自己缓存的数据中查找，找到了就返回，找不到就将去请求转发给根域名服务器，它不能直接解析域名，但可以指一条路
- 根域名服务器收到本地DNS,根据域名后缀返回顶级域名服务器的地址
- 本地DNS向顶级域名服务器发起请求，返回负责权威域名服务器
- 本地DNS向权威域名服务器发起请求，返回IP
- 本地DNS向客户端返回IP

#### CDN
CDN 多级架构可以依次分为 中心节点层，区域节点层和边缘节点层。  

有了 CDN 后，在权威 DNS 服务器上，会设置一个 CNAME 指向连个一个域名 `www.web.cdn.com`, 返回给本地DNS服务器，本地 DNS 服务器拿到这个新的域名后，需要继续解析这个新的域名，从而
访问到CDN网络的全局负载均衡器，全局负载均衡器会为用户选择一台合适的缓存服务器。


