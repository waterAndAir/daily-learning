## CPU 
CPU 的消耗除了来自于用于执行程序，还有相当一部分来自于上下文切换，中断(硬中断和软中断)，IO等待。

### 平均负载
平均负载的理想情况应该等于 CPU 数，实际中，将超过 CPU 数量的的 70% 作为警告的阈值。
#### 查看平均负载
```shell script
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```
从左到右依次表示：
- 当前时间
- 系统运行时间
- 正在登录的用户数
- 过去1分钟，5分钟，15分钟的平均负载（Load Average）， 表示平均活跃进程数， 和 CPU 使用率没有直接关系

#### 辨析平均负载和CPU使用率
平均负载： 单位时间内处于可运行状态和不可中断状态的进程数  
CPU 使用率： 单位时间内CPU的繁忙情况  

- CPU 密集型进程： 平均负载和CPU使用率变化一致，都会升高
- I/O 密集型进程： 等待IO属于不可中断状态，平均负载会升高,但 CPU 此时可能在空等，所以使用率不一定高
- 进程较多，等待CPU调度也会导致平均负载和CPU使用率同时升高

### CPU 使用率

CPU 使用率 = 1 - 空闲时间/总CPU时间  

一般性能分析工具，会取一个时间段计算平均CPU使用率：  

CPU 平均使用率 = 1 - （空闲时间2 - 空闲时间1）/ (总CPU时间2 - 总CPU时间1)  

所以在对比不同工具分析的时候，要注意它们的间隔时间是否一致，top 一般为 3 秒，而 ps 是取的进程的整个生命周期

#### CPU 使用率相关的指标
```
top - 16:03:50 up 10:37,  3 users,  load average: 0.06, 0.01, 0.00
Tasks: 104 total,   1 running,  57 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st
KiB Mem :  4040012 total,  3407476 free,    93848 used,   538688 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3708964 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    1 root      20   0   77932   9048   6680 S  0.0  0.2   0:02.09 systemd
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd
    4 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 kworker/0:0H
    6 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 mm_percpu_
```
- us(user): 用户态 CPU 时间。不包括 nice 时间，但包括了 guest 时间
- ni(nice): 低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。nice 可取值范围是 -20 到 19，数值越大，优先级越低
- sys(system): 内核态 CPU 时间
- id(idle): 代表空闲时间。不包括等待 I/O 的时间（iowait）
- wa(iowait): 代表等待 I/O 的 CPU 时间
- hi(irq): 代表处理硬中断的 CPU 时间
- si(softirq): 代表处理软中断的 CPU 时间
- st(steal): 代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间
- guest: 代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间
- gnice(guest_nice): 代表以低优先级运行虚拟机的时间

### CPU 上下文
CPU 会不断的轮换正在执行的进程，以此实现多任务的效果，在每次切换的时候，需要系统为准备好寄存器和计数器，它们就是CPU的上下文：  

- 寄存器：CPU 内置的容量小、但速度极快的内存。
- 计数器：存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

过多的上下文切换，会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。

根据任务的不同，CPU切换可以分为三个场景：进程上下文切换，线程上下文切换，中断上下文切换
#### 进程上下文切换
进程的运行在内核空间时称为内核态，运行在用户空间时称为用户态：

- 内核态：具有最高权限，可以直接访问所有资源
- 用户态：部分资源访问受限，必须通过系统调用将进程转化到内核态才能访问受限的资源，比如内存

##### 进程内的上下文切换（特权模式切换）
进程在进行系统调用时，也会发生 CPU 上下文切换。进行进行系统调用时，CPU 寄存器要将用户态的指令位置保存先来，再将内核态的指令位置更新到寄存器上，才可以执行，
执行结束后，CPU 寄存器需要相似的步骤切换回用户态继续执行用户代码。所以一次系统调用会发生两次 CPU 上下文切换。  

系统调用过程中一直在一个进程内，所有不需要切换进程的虚拟内存，栈等资源。  这个过程比较快

##### 进程间的上下文切换
进程是由内核来管理和调度的，进程的切换只能发生在内核态。
进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态，所以切换进程很耗资源。    

###### 进程上下文切换的场景
- 程序执行完终止，释放 CPU，从就绪队列中取出新的进程运行
- CPU 根据进程的优先级和等待CPU的时间选择进程进行切换，CPU 资源被划分为一段段的时间片，当某个进程的时间片耗尽了，就会进行上下文切换
- 当资源(比如内存)不足时，会将进程挂起等待资源满足后再执行，这时会切换上下文，系统会调度其他进程运行
- 进程调用 sleep 函数主动挂起
- 当有优先级高的进程时，会进行上下文切换，挂起优先级低的进程
- 发生硬件(比如网卡 硬盘 键盘等)中断, 网卡接收到一个数据包，也会发出一个中断，此时CPU上执行的进程会被挂起，转而执行内核上的中断服务。

#### 线程上下文切换

- 线程是调度的基本单位， 内核中的任务调度，实际上的调度对象是线程
- 进程给线程提供了虚拟内存、全局变量等资源
- 两个线程属于不同进程时，切换过程就跟进程上下文切换是一样的
- 两个线程属于同一个进程时，只需要切换线程的私有数据、寄存器等不共享的数据

#### 中断上下文切换
中断处理比进程拥有更高的优先级， 中断上下文切换不涉及到进程的用户态，只包括内核态中断进程的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。
大部分中断都会很快执行，但大量的中断切换还是会降低整体性能。