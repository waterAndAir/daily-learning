# 理解分布式日志一致性算法 Raft
循序渐进，由浅入深的理解 raft 
## Replicated state machines (复制状态机)  

`一个状态机`从"初始"状态开始，每一个"输入"都被传入"转换函数"和"输出函数"，以生成一个新的状态和输出。
在新的输入被接收到前，状态保持不变，而输出同时被传输给恰当的接受者。  

`复制状态机` 就是同时有多个同样的状态机,使它们让一个状态机一样, 从"初始状态"开始,经历相同的输入后达到同样的状态和`相同序列`的输出结果.  

一致性算法就是用来保证`复制状态机`的按照预期正确运行,即使某个状态机在运行过程中宕机,在它恢复运行后,依然可以保证它的状态和输出序列与正常的状态机相同.

复制状态机具有以下特性:
- 安全性: 在非[拜占庭错误](https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98)(网络节点中没有破坏者)情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。
- 可用性: 集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。
- 不依赖时序保证一致性: 不会因为物理时钟不一致或者消息延迟导致不可用
- 快速响应: 大部分节点可以快速做出响应,不会因为个别较慢节点拖慢整体性能


在 `Etcd` 这个项目中, `复制状态机` 就是`kv`存储模块, 运行在多个节点上的 etcd kv 存储,在一致性算法 raft 模块的支持下,实现了复制状态机的
特性.  
 

## Raft 协议
raft 协议从设计开始就将通俗易懂作为其目标之一，为此它将一致性问题分解成了几个相对独立的问题：领导者选举，日志复制，日志压缩，安全性和角色改变，
这些在后面会分别详细讲到。

### 名词解释
#### 节点的三种状态
##### 领导者 （Leaders）
- 负责所有客户端的请求
- 负责向所有 Follower 节点发送心跳信息
- 处理写请求时,会先在本地记录一条日志,同时将请求转发给所有 Follower, 当收到超过半数的来自 Follower 的写入成功响应时,则给客户端返回写入成功.
##### 跟随者 （Followers)
- Follower 节点只负责与 Leader 保持同步一致,它只能接收请求,来自 Leader 节点的写入请求和心跳请求和来自 candidate 节点的投票请求 
- 当长时间接收不到 Leader 的心跳，等待一段时间后（election timeout），Follower 会切换到候选人状态。

##### 候选人 （Candidates)
- 当 Follower 节点长时间没有收到来自 master 的心跳时,会切换为 Candidate 节点.
- 向其它节点发投票请求，为自己拉选票，如果接收到大多数节点的选票，就将状态转变为领导者，如果接收到新的领导人的日志请求，就转变为跟随者

#### Term 任期号

- Term 是一个从 0 开始的全局递增的整数. 
- 每个节点都会记录当前自己所处的任期(currentTerm).
- 每次 Candidate 节点发起选举时,都会将自己的任期号 +1 



### Leader 选举

#### 集群初始化时的选举流程

- 集群初始化时,所有节点都是 Follower 节点.
- 因为没有 Leader 节点,所以 Follower 节点无法收到心跳信息, 当某个 Follower 超过选举超时时间(election timeout)后, 它会切换为 Candidate 节点. (election timeout 一般为 150~300ms 随机数,以此避免多个 Follower 同时收到 心跳信息)
- Candidate 发起选举请求,赢得选举的 Candidate 转换为 Leader 节点并向其他所有节点发送心跳信心, 其他 Candidate 节点(如果存在的话) 收到心跳信息后,切换为 Follower 节点.

#### 选举细节
- 当 Follower 节点收到 Candidate 的投票请求后,也会重置自己的 election timeout, 防止一个任期中同时出现多个 Candidate 节点
- Follower 节点收到选举请求后,会依次经过一系列对比来决定是否要为目标 Candidate 节点投票:
- - 对比任期号, 给任期号大的投票
- - 对比日志索引记录,给索引值大的投票
- Follower 节点投出选票后,会更新自己的任期号为投票请求中的任期号

### 日志复制
基本流程:
- 客户端向 Leader 节点发送写操作请求
- Leader 节点将请求记录到自己的本地日志, 并以 `AppendEntries`(记录了最近收到的请求日志) 的形式向所有 Follower 节点发送消息
- Follower 节点接收到 Leader 发来的 `AppendEntries` 消息后,会将请求记录到自己的本地日志,并向 Leader 节点响应相应的消息
- 当 Leader 节点收到半数以上的 Follower 节点的响应后,会对客户端返回写入成功的响应
- 之后, Leader 节点会对该条 Entry 做提交(commit)操作,并应用到自己的状态机中,对于 Etcd 而言,这一步就是将 Entry 存入对应Storage.
- 最后, Leader 再次向所有Follower节点发送消息,告知 Follower 节点该 Entry 已经提交, Follower 会将该 Entry 节点应用到自己的状态机中,




### 日志压缩
为了避免日志无限增加,raft 引入了快照机制.  
集群中的每个节点都会自己独立,定时的创建快照,在进行恢复时,会先使用本地最新的快照.如果节点长时间宕机后,Leader 节点会将自己的快照通过另一个消息
通道发送给Follower.  

如果Follower节点接收到的快照包含自己记录的全部日志,那么Follower会抛弃自己的全部日志;如果快照只包含Follower的一部分日志,那么Follower会删除快照中
包含的日志,保留快照之后的日志.



### 安全

  




## 关键变量解释

**在所有服务器上持久存在的:**  
- `currentTerm` 服务器最后一次知道的任期号(初始化为 0, 持续递增)
- `votedFor` 在当前获得选票的候选人ID 
- `log[]` 日志集合(log entries), 每一个 entry 包含一个 

