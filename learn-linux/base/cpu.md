## CPU 
CPU 的消耗除了来自于用于执行程序，还有相当一部分来自于上下文切换，中断(硬中断和软中断)，IO等待。

### 平均负载
平均负载的理想情况应该等于 CPU 数，实际中，将超过 CPU 数量的的 70% 作为警告的阈值。
#### 查看平均负载
```shell script
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```
从左到右依次表示：
- 当前时间
- 系统运行时间
- 正在登录的用户数
- 过去1分钟，5分钟，15分钟的平均负载（Load Average）， 表示平均活跃进程数， 和 CPU 使用率没有直接关系

#### 辨析平均负载和CPU使用率
平均负载： 单位时间内处于可运行状态和不可中断状态的进程数  
CPU 使用率： 单位时间内CPU的繁忙情况  

- CPU 密集型进程： 平均负载和CPU使用率变化一致，都会升高
- I/O 密集型进程： 等待IO属于不可中断状态，平均负载会升高,但 CPU 此时可能在空等，所以使用率不一定高
- 进程较多，等待CPU调度也会导致平均负载和CPU使用率同时升高

### CPU 使用率

CPU 使用率 = 1 - 空闲时间/总CPU时间  

一般性能分析工具，会取一个时间段计算平均CPU使用率：  

CPU 平均使用率 = 1 - （空闲时间2 - 空闲时间1）/ (总CPU时间2 - 总CPU时间1)  

所以在对比不同工具分析的时候，要注意它们的间隔时间是否一致，top 一般为 3 秒，而 ps 是取的进程的整个生命周期  

根据运行任务的不同，又被分为以下几种：  
- 用户CPU: 
- 系统CPU 
- 等待I/O CPU
- 软中断和硬中断

#### CPU 使用率相关的指标
```
top - 16:03:50 up 10:37,  3 users,  load average: 0.06, 0.01, 0.00
Tasks: 104 total,   1 running,  57 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st
KiB Mem :  4040012 total,  3407476 free,    93848 used,   538688 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3708964 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    1 root      20   0   77932   9048   6680 S  0.0  0.2   0:02.09 systemd
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd
    4 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 kworker/0:0H
    6 root       0 -20       0      0      0 I  0.0  0.0   0:00.00 mm_percpu_
```
- us(user): 用户态 CPU 时间。不包括 nice 时间，但包括了 guest 时间
- ni(nice): 低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。nice 可取值范围是 -20 到 19，数值越大，优先级越低
- sys(system): 内核态 CPU 时间
- id(idle): 代表空闲时间。不包括等待 I/O 的时间（iowait）
- wa(iowait): 代表等待 I/O 的 CPU 时间
- hi(irq): 代表处理硬中断的 CPU 时间
- si(softirq): 代表处理软中断的 CPU 时间
- st(steal): 代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间
- guest: 代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间
- gnice(guest_nice): 代表以低优先级运行虚拟机的时间

### CPU 上下文
CPU 会不断的轮换正在执行的进程，以此实现多任务的效果，在每次切换的时候，需要系统为准备好寄存器和计数器，它们就是CPU的上下文：  

- 寄存器：CPU 内置的容量小、但速度极快的内存。
- 计数器：存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

过多的上下文切换，会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。

根据任务的不同，CPU切换可以分为三个场景：进程上下文切换，线程上下文切换，中断上下文切换
#### 进程上下文切换
进程的运行在内核空间时称为内核态，运行在用户空间时称为用户态：

- 内核态：具有最高权限，可以直接访问所有资源
- 用户态：部分资源访问受限，必须通过系统调用将进程转化到内核态才能访问受限的资源，比如内存

##### 进程内的上下文切换（特权模式切换）
进程在进行系统调用时，也会发生 CPU 上下文切换。进行进行系统调用时，CPU 寄存器要将用户态的指令位置保存先来，再将内核态的指令位置更新到寄存器上，才可以执行，
执行结束后，CPU 寄存器需要相似的步骤切换回用户态继续执行用户代码。所以一次系统调用会发生两次 CPU 上下文切换。  

系统调用过程中一直在一个进程内，所有不需要切换进程的虚拟内存，栈等资源。  这个过程比较快

##### 进程间的上下文切换
进程是由内核来管理和调度的，进程的切换只能发生在内核态。
进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态，所以切换进程很耗资源。    

###### 进程上下文切换的场景
- 程序执行完终止，释放 CPU，从就绪队列中取出新的进程运行
- CPU 根据进程的优先级和等待CPU的时间选择进程进行切换，CPU 资源被划分为一段段的时间片，当某个进程的时间片耗尽了，就会进行上下文切换
- 当资源(比如内存)不足时，会将进程挂起等待资源满足后再执行，这时会切换上下文，系统会调度其他进程运行
- 进程调用 sleep 函数主动挂起
- 当有优先级高的进程时，会进行上下文切换，挂起优先级低的进程
- 发生硬件(比如网卡 硬盘 键盘等)中断, 网卡接收到一个数据包，也会发出一个中断，此时CPU上执行的进程会被挂起，转而执行内核上的中断服务。

#### 线程上下文切换

- 线程是调度的基本单位， 内核中的任务调度，实际上的调度对象是线程
- 进程给线程提供了虚拟内存、全局变量等资源
- 两个线程属于不同进程时，切换过程就跟进程上下文切换是一样的
- 两个线程属于同一个进程时，只需要切换线程的私有数据、寄存器等不共享的数据

#### 中断上下文切换
中断处理比进程拥有更高的优先级， 中断上下文切换不涉及到进程的用户态，只包括内核态中断进程的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。
大部分中断都会很快执行，但大量的中断切换还是会降低整体性能。

### 中断
中断是响应硬件设备请求的一种异步的事件处理机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。

CPU 为了快速处理中断程序，将其过程分为了两个步骤，硬中断和软中断：
- 硬中断：直接处理硬件请求，在中断禁止模式下快速运行，它会打断CPU正在执行的任务，立即执行中断处理程序
- 软中断：由内核触发，延迟处理上一步未完成的工作，通常以内核线程的方式运行，每个CPU对应一个软中断内核线程，名为 `ksoftirqd/CPU编号`；软中断除了来自于硬中断，内核自定义的一些事件也属于软中断，比如内核调度和RCU锁

以网卡设备接收数据包中断事件为例：  
- 网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。
- 硬中断：将网卡数据读到内存，更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下一步的处理
- 软中断：从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

#### 查看软中断和内核线程
`/proc/softirqs` 提供了软中断的运行情况  
`/proc/interrupts`提供了硬中断的运行情况。

```shell script
root@ubuntu-vm:~$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:          1          0          0          0
       TIMER(定时中断): 1020189927  983392064  980802249  998314540
      NET_TX(网络发送中断):          6          0          0          0
      NET_RX(网络接收中断):  467253728  670205491  196150048  389768608
       BLOCK:          0          0          0          0
BLOCK_IOPOLL:          0          0          0          0
     TASKLET:          3         13          1          1
       SCHED(内核调度):  649436485  606246066  595990791  587987098
     HRTIMER:          0          0          0          0
         RCU(内核常用的锁):  859343334  824079502  817872736  827593042
```
```shell script
# 每个CPU对应一个软中断内核线程，查看这些线程的运行状态，在[]中表示是内核线程
root@ubuntu-vm:~$ ps aux | grep softirqd
root         3  0.0  0.0      0     0 ?        S     2019  13:01 [ksoftirqd/0]
root        13  0.0  0.0      0     0 ?        S     2019  11:36 [ksoftirqd/1]
root        18  0.0  0.0      0     0 ?        S     2019   5:18 [ksoftirqd/2]
root        23  0.0  0.0      0     0 ?        S     2019   6:18 [ksoftirqd/3]
```

#### 软中断事件过载问题
当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，进而引发网络收发延迟、调度缓慢等性能问题。  

但实际生产中，软中断遇到的性能瓶颈大多是网络收发类型的，特别是网络接收的软中断，比如web服务器遇到了 SYN FLOOD 攻击，这时就应该使用 sar 和 tcpdump 找出正在
产生大量软中断的网卡以及源IP。

### 优化
#### 应用程序层
- 编译器优化
- 算法优化
- 异步处理
- 多线程替换多进程
- 缓存

#### 系统层
- CPU 绑定： 进程绑定到一个或多个CPU上，提高CPU缓存命中率，减少跨CPU调度
- CPU 独占： CPU 由指定的进程独占，不允许其他进程使用这些CPU
- 优先级调整： 调整进程的 nice 值，降低非核心进程的优先级，提高核心进程的优先级
- 设置进程资源限制： cgroup， 防止耗尽系统资源
- NUMA（Non-Uniform Memory Access）: 
- 中断的负载均衡： 开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上
