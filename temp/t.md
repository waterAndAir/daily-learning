##### TODO 谈谈Open-Tracing
- Tracer
- Carrier Inject Extract
- Span
- Tag
- Log
- Baggage 



##### 谈谈 snowflake 原理？
64位二进制
- 1：标志位
- 41：毫秒
- 10： 机器码
- 12： 序列号

时钟回拨问题的解决:
- 1. 有限的解决，如果并发并不大的话，比如 30w/qps,平均每毫秒产生 300 个，与设计的 4096 还差的远，当发生时钟回拨后，可以将基础序列设置为一个较高的的值，而不是初始化的 0， 比如设置成 1024；
- 2. 与上面的思路一样，只不过操作的是 workerID， 因为 workerID 一般用不完，可以给每个节点准备多个 workerID， 发生时钟回拨就换workerID
- 3. 如果时钟回拨的时间比较短，可以等一下


- https://tech.meituan.com/2019/03/07/open-source-project-leaf.html
- https://tech.meituan.com/2017/04/21/mt-leaf.html

##### 设计安全的API
- 加密:对称、非对称，对称和非对称结合
- 加签：rsa
- 时间戳: 在请求中加入时间戳，服务端解密后，检查时间戳是否在符合的范围内
- appid: 唯一，不连续，snowflake 可以
- 限流：
  - 固定窗口: 60s 内允许 100 个请求，不能应对激增流量
  - 滑动窗口: 优化固定窗口，在窗口总加入n个格子，格子越多限流越精确
  - 令牌桶:
  - 漏斗:
- 黑名单：
- 数据合法性检测：

##### 工作中遇到的 Bug？
- golang float 精度问题，IEEE 754, 用 math.Round() 解决：
```
在做 jspay 支付时，接收前端传来的元为单位的 float 类型金额，在后端需要乘 100 转化为分为单位。直接乘 100， 发现精度有问题，比如 40.3 * 100， 
结果是 4029，少了一分钱，被用户误以为黑他钱。
原理的浮点数在计算机中的存储不像整数那么直接，有多种方式。比如：
- 定点数表示法
- 有理数表示法，
- 浮点数表示法，Golang采用的是 IEEE 754 标准，这也是应用最广泛的标准。

最终解决的办法是四舍五入。
```
- 调用第三方接口，忘记加 timeout， 引起队列堆积告警。

##### 自我介绍
你好，我叫张吉，16年毕业，最近两年在北京乐惠科技工作，在这里开始用 Golang 做主要开发语言，主要负责将公司支付系统从 PHP 迁移到 Golang，
经过服务化拆分，存储层改造，建立开放平台等一系列工作，为公司构建了一套具有高可扩展性的支付系统。在此之前，在北京蓝墨教育和武汉天喻教育各待过一年，主要用PHP
做 http 接口，也用 Python 做过数据处理，也写过前端。在乐惠这两年确立了今后以Golang为主的后端开发的发展路线。我性格偏内向，但因为喜欢运动，也具有外向的一面。

##### 开发组织模式是？
在开发支付开放平台前是我和组长两个人，组长主要负责 Review，包括 review 设计方案和代码，上线监控等工作，我负责具体的设计，开发，测试等工作。

##### 优缺点

- 优点：认真谨慎，对任务负责，写完代码一定会先 review，然后再做大量的测试。待人友好真诚，会主动交流，喜欢合作，善于发展持久的关系。善于安排好生活，坚持锻炼，坚持健康饮食。
- 缺点：过去最大的缺点也是遗憾，是对业务缺乏全局的了解，这也是我想在新环境中最优先改正的问题，不能只顾自己负责的业务。在学习上没有找到专注的点，

##### 在公司两年，就负责了这几个项目吗
用户体系改造，B端API
##### 你的爱好
运动，从合作竞争，交朋友的角度讲

##### 你想找个什么样的工作和团队？
追求质量和效率 鼓励学习

##### 业务、技术、管理的关系？
业务产生价值，技术为业务服务，管理促进技术更好的为业务服务。


##### 公司的其他业务了解吗？
- 支付 2
- 进件 2
- 对账结算 2
- 营销活动 1
- 储值 1
- 扫码点餐 2
- 商户端管理系统，客服端管理系统， BD 端管理系统 6
- 扫码盒子扫码枪 1
- PC 插件 2
- APP 2
- 前端 1
- 数据中台 2

# raft
## Raft 协议
raft 协议从设计开始就将通俗易懂作为其目标之一，为此它将一致性问题分解成了几个相对独立的问题：领导者选举，日志复制，日志压缩，安全性和角色改变，
这些在后面会分别详细讲到。

### 名词解释
#### 节点的三种状态
##### 领导者 （Leaders）
- 负责所有客户端的请求(`注意，是所有读写请求`)
- 负责向所有 Follower 节点发送心跳信息
- 处理写请求时,会先在本地记录一条日志,同时将请求转发给所有 Follower, 当收到超过半数的来自 Follower 的写入成功响应时,则给客户端返回写入成功.
##### 跟随者 （Followers)
- Follower 节点`只负责与 Leader 保持同步一致`,它只能接收请求,来自 Leader 节点的写入请求和心跳请求和来自 candidate 节点的投票请求 
- 当长时间接收不到 Leader 的心跳，等待一段时间后（election timeout），Follower 会切换到候选人状态。

##### 候选人 （Candidates)
- 当 Follower 节点长时间没有收到来自 master 的心跳时,会切换为 Candidate 节点.
- 向其它节点发投票请求，为自己拉选票，如果接收到大多数节点的选票，就将状态转变为领导者，如果接收到新的领导人的日志请求，就转变为跟随者

#### Term 任期号

- Term 是一个从 0 开始的全局递增的整数. 
- 每个节点都会记录当前自己所处的任期(currentTerm).
- 每次 Candidate 节点发起选举时,都会将自己的任期号 +1 

### Leader 选举

#### 集群初始化时的选举流程

- 集群初始化时,所有节点都是 Follower 节点.
- 因为没有 Leader 节点,所以 Follower 节点无法收到心跳信息, 当某个 Follower 超过选举超时时间(election timeout)后, 它会切换为 Candidate 节点. (election timeout 一般为 150~300ms 随机数,以此避免多个 Follower 同时收到 心跳信息)
- Candidate 发起选举请求,赢得选举的 Candidate 转换为 Leader 节点并向其他所有节点发送心跳信心, 其他 Candidate 节点(如果存在的话) 收到心跳信息后,切换为 Follower 节点.

#### 选举细节
- 当 Follower 节点收到 Candidate 的投票请求后,也会重置自己的 election timeout, 防止一个任期中同时出现多个 Candidate 节点
- Follower 节点收到选举请求后,会依次经过一系列对比来决定是否要为目标 Candidate 节点投票:
- - 对比任期号, 给任期号大的投票
- - 对比日志索引记录,给索引值大的投票
- Follower 节点投出选票后,会更新自己的任期号为投票请求中的任期号

### 日志复制
基本流程:
- 客户端向 Leader 节点发送写操作请求
- Leader 节点将请求记录到自己的本地日志, 并以 `AppendEntries`(记录了最近收到的请求日志) 的形式向所有 Follower 节点发送消息
- Follower 节点接收到 Leader 发来的 `AppendEntries` 消息后,会将请求记录到自己的本地日志,并向 Leader 节点响应相应的消息
- 当 Leader 节点收到半数以上的 Follower 节点的响应后,会对客户端返回写入成功的响应
- 之后, Leader 节点会对该条 Entry 做提交(commit)操作,并应用到自己的状态机中,对于 Etcd 而言,这一步就是将 Entry 存入对应Storage.
- 最后, Leader 再次向所有Follower节点发送消息,告知 Follower 节点该 Entry 已经提交, Follower 会将该 Entry 节点应用到自己的状态机中,

### 日志压缩
为了避免日志无限增加,raft 引入了快照机制.  
集群中的每个节点都会自己独立,定时的创建快照,在进行恢复时,会先使用本地最新的快照.如果节点长时间宕机后,Leader 节点会将自己的快照通过另一个消息
通道发送给Follower.  

如果Follower节点接收到的快照包含自己记录的全部日志,那么Follower会抛弃自己的全部日志;如果快照只包含Follower的一部分日志,那么Follower会删除快照中
包含的日志,保留快照之后的日志.

### 安全

 
## 关键变量解释

**在所有服务器上持久存在的:**  
- `currentTerm` 服务器最后一次知道的任期号(初始化为 0, 持续递增)
- `votedFor` 在当前获得选票的候选人ID 
- `log[]` 日志集合(log entries), 每一个 entry 包含一个 


### raft

##### etcd raft 避免网络分区造成的频繁选举
// 如果开启了 PreVote 模式,当 Follower 节点的选举计时器超时后,会先调用 becomePreCandidate() 将当前状态切换到 PreCandidate 的状态,
// 在 PreCandidate 状态下的节点会先确定自己是否可以与其他节点通信,以此决定自己是否可以转换为 Candidate 状态,
// 这一步是 Raft 为了避免网络分区造成的频繁选举.