##### Mysql 长连接引起的 OOM 
因为建立连接比较复杂，所以建议使用长连接。但由于mysql执行过程中的临时使用的内存是连接对象管理的，
所以，连接长时间不关闭会导致内存占用，有两种解决方法：  
- 定期断开长连接，或者在程序中判断，执行了一个占用大量内存的查询后，主动断开连接
- 5.7版本后，在执行占用内存大的查询后，执行 `mysql_reset_connection` 可以初始化连接资源，此操作不需要重连和权限验证

##### 避免长事务
长事务意味着需要存很多视图，导致占用大量的存储空间。  
- 设置 `set autocommit = 1`, 显式声明事务的开始和结束
- 去掉不必要的只读事务
- 根据业务预估事务执行的时间，设置合适的 `MAX_EXECUTION_TIME`
- 监控 `information_schema.Innodb_trx` 表，发现长事务就报警或 kill 掉
- 测试阶段要求输出 general_log 日志，分析日志行为提前发现问题
- 尝试使用 pt-kill 工具

##### 为什么要重建索引
索引可能因为删除， 或者页分
裂等原因， 导致数据页有空洞， 重建索引的过程会创建一个新的索引， 把数据按顺序插入， 这样
页面的利用率最高， 也就是索引更紧凑、 更省空间

##### 索引的一些概念
- 覆盖索引：查询一次索引树就可以，不需要回表
- 左前缀原则：
- 索引下推：mysql 5.6 后的优化，使用联合索引时，不符合最前缀的部分，会先对索引中包含的字段的条件进行筛选
##### 锁的一些概念
###### 全局锁
全局锁会使数据库的写操作全部停止，它的应用场景一般是做全库的逻辑备份，通过 Flush tables with read lock (FTWRL) 加锁，然后做备份。  
对于不支持事务的存储引擎通常是采用这种方式的。  
对于支持事务的存储引擎可以通过开启一个事务的方式，难道当前时间节点的视图，对这个视图进行备份。
###### 表级锁
表级锁用两种: 1. 表锁 2. 元数据锁(MDL)  

表锁 lock tables ...read/write 可以用unlock tables主动释放锁，这种方式除了限制了别的线程的读写外，也限制了当前线程接下来的操作对象，比如:  
执行 `lock table t1 read,t2 write`，除了会导致其他连接不能对 t1 写，不能对 t2 读写外，还会导致当前连接不能对 t1 写。  

MDL 不需要显示的声明，在访问一个表时会被自动加上。当对一个表做 DML 操作的时候，加MDL读锁;当要对表 DDL 操作的时候，加MDL写锁。  
读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线 程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。  
MDL会直到事务提交才释放, 所以如果存在长事务，在修改表结构的时候，可能会造成长时间的阻塞。

###### 行级锁
行锁是在引擎层实现的。在 Innodb 中行锁是在需要的时候才加上的，但并不是不需要了就马上释放，而是等到事务提交了才会释放锁(两阶段锁协议)。如果事务中需要锁多个行，要把最可能造成冲突，最可能影响并发度的锁尽量往后放，这样可以最大程度的减少事务之间的锁等待。  

行级锁的粒度最小，也最容易放生死锁。为了避免死锁将 CPU 打爆，有两种方法：  
1. 设置锁等待超时时间 `innodb_lock_wait_timeout`, 
2. 发起死锁检测，设置 `innodb_deadlock_detect` 为on, 发现死锁后，主动回滚死锁链条中某一个事务，让另一个事务得以继续运行 (推荐此方法)