### 数组，栈，队列，hashmap
##### LRU 算法的实现思路
链表 + hash 表

##### hash 冲突
- 开放寻址法
- - 线性探测
- - 二次方探测
- - 双重 hash
- 链表法，又称拉链法

##### 布隆过滤器
- 是一个很长的二进制向量和一系列随机映射函数
- 使用位图做存储，可以节省内存，但如果数字的范围过大，也很耗内存，布隆过滤器就是为了解决这个问题
- 使用多个 hash 函数，计算出多个 hash 值用于定位
- 有误判：判不存在一定不存在；判存在不一定存在。
- 通过调整 hash 函数个数和位图大小，降低误判率

应用：
- 黑名单
- 单词拼写检查
- 爬虫 url 去重
- 缓存的缓冲：比如，将所有用户信息的phone或email 放入布隆过滤器，新用户注册时，判断该用户的 phone， email 在不在布隆过滤器，如果不在，就允许用户继续注册，如果在，就去查缓存，查库，看看是不是真的在


##### 索引的基础数据结构
- 散列表：redis，memchache，性能超好，在内存中
- 红黑树：适合内存索引
- B+数：适合构建存在磁盘的索引
- 跳表：redis zset，平衡了对内存的消耗和查询效率，按区间查询效率高于 AVL


##### 二分查找
特点：数组，有序，数据量不能太大。   


变形问题：
- 查找第一个值等于给定值的元素
- 查找最后一个值等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找第一个小于等于给定值的元素


使用了二分思想的数据结构：
- 跳表

### 排序
##### 排序算法思路：
- 冒泡 O(n^2)：
- 插入 O(n^2)：
- 选择 O(n^2)：
- 快排 O(nlogn)：可以通过选择分区点优化：随机法、三数取中、多数取中
- 归并 O(nlogn)：
- 桶 O(n)：先根据范围分桶，在桶中使用快排
- 计数 O(n)：特殊的桶，每个桶代表的范围是 1
- 基数 O(n)(要求数据高低位之间有递进关系)：先比较高位，需要的话再比较低位



##### 根据数据的特征选择合适的算法：
- 有没有可能包含大量重复的元素？ 如果有，三路快排是更好的选择，否则基本快排
- 是否近乎有序？如果是，选择插入排序
- 是否数据的取值范围十分有限，比如学生成绩？如果是，选择计数排序
- 是否需要稳定一点的排序？如果是，选择归并排序
- 如果的存储结是怎样的？如果是链表，选择归并排序;顺序表选择快排
- 数据是否可以完全存入内存？如果不能，选择外排序
- 如果数据量比较小，选择插入排序


### 树
#### 二叉树性质 
- 性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i>0）
- 性质2: 深度为k的二叉树至多有2^k - 1个结点（k>0）
- 性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;
- 性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)
- 性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）

#### 数的分类
- 完全二叉树
- 满二叉树，是一种特殊的完全二叉树
- 二叉排序树：对于每一个节点，左子树元素小于节点，右子树元素大于节点
- 平衡二叉树
 

#### 堆
- 完全二叉树(方便用数组实现)


##### 应用
- topK： 最小堆，比堆顶元素大的先删除堆顶，再添加该元素
- bottomK： 最大堆，比堆顶元素小的先删除堆顶，再添加该元素
- 优先队列
- 求中位数/99%响应时间：用一个大顶堆和一个小顶堆，各存一部分元素，比如对于求中位数，就是各放一半数量的元素
- 定时器
- 合并N个含有有序内容的文件，并保持有序：开 N 个 IO 流，每个 IO 流读取一定量内容放到小顶堆,最后依次遍历堆.

#### Trie 线段树

##### 应用
- golang httprouter
- 搜索框的及时响应


### 算法思想
- 贪心：一路走到黑，就一次机会
- 回溯：一路走到黑，无数次重来的机会
- 动态规划：上帝视角，一次找到最优解
- 分治： mapreduce