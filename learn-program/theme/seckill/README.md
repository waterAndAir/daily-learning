### 原则
- 数据尽量少：减少给用户返回的数据，减少用户直接访问到服务端的数据
- 请求尽量少：合并css，images，JavaScript
- 路径尽量短：减少中间节点数，将 RPC 服务转为本地函数调用
- 服务分级：保证强依赖，做好弱依赖的服务降级
- 消除单点：把服务无状态化，使其易于水平扩展
- 独立数据库：最好使用独立的数据库
- 设计保护措施
### 高性能
- 秒杀页面动静分离， 静态数据存入 CDN, 动态数据存入缓存
- 服务端本地缓存秒杀商品，直接存到 array 或 map 中， 这样设置不需要到专门的缓存集群中查询数据
- 

#### 动静分离
个性化数据为动态数据，其余的每个人访问的都一样的数据，为静态数据。

对于分离出的静态数据可以：  
- 缓存到离用户近的地方，比如浏览器中，CDN 或服务端 Cache
- 静态化改造是直接缓存HTTP连接，Web 代理服务器（nginx）根据请求的 URL 直接返回 http Header 和 Body  

#### 发现热点数据
- 用户主动上报
- 异步监控，大数据实时计算

#### 流量削峰
##### 排队
通过消息队列来缓冲瞬时流量，把同步调用转换成异步间接推送。  
要注意消息积压的问题。
##### 答题
设计答题系统，一方面防止机器人请求，另一方面可以延缓请求，起到对请求流量进行削峰的而作用。  

注意点：  
- 题目最终有应该生成为图片格式，并且在图片中加入干扰元素。  
- 答题系统为一个用户返回一个题目的时候要记录当下的时间，用于限制非法用户答题的时间，如果小于 1s，很可能不是人 

##### 分层过滤
分层结构大致可分为： CDN 层 -> 前台读系统 -> 后台写系统 -> 数据库。  

请求每到一层都应该被过滤掉一部分，保证最终只有少部分请求时走到数据库的。  

- 将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；
- 对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；（甚至在读库存的时候也可以不验证，在真正下单的时候再用数据库做一致性验证也可以）
- 对写数据进行基于时间的合理分片，过滤掉过期的失效请求；
- 对写请求做限流保护，将超出系统承载能力的请求过滤掉；
- 对写数据进行强一致性校验，只保留最后有效的数据。

### 库存
秒杀系统中的一致性问题，最突出的就是 "减库存"的问题

#### 下单减库存
这种方式最容易控制。但如果有人下单不付款，就会有剩余库存。   

先创建订单但是先不生效，然后减库存，如果减库存成功后再生效订单，否则订单不生效。  
  
会有恶意下单占用库存，这个问题需要结合安全和反作弊的措施解决，或给商品设置最大购买件数，限制重复下单不付款的操作次数。  

秒杀系统中不付款的情况较少，这种方式是比较适合的。
#### 付款减库存
下单时不减库存，在真正付款成功时，才减库存，如果并发高，可能会出现下单后付不了款的情况  

存在的问题： 
- 会超卖，导致有的用户下单成功了，但支付失败，体验较差

#### 预扣库存
用户下单后，预扣库存，库存为其保留 5分钟，超时未支付，库存会被释放，释放后其他用户可以继续购买。用户付款时，会校验该订单的库存是否还在保留期，
如果没有保留，需要重新校验库存量，如果库存不足就不允许付款。如果在库存还在保留，则完成付款并实际的减去库存。

#### 优化
- 如果库存的逻辑简单，且商品数量较少，可以在持久化缓存系统中做减库存的操作
- Mysql 因为行锁的原因，在减库存场景下会产生大量的锁等待，甚至会拖慢整个数据库的性能，所以尽量可以把参与秒杀活动的库存数据单独放在一个库中
- 并发锁的问题，可以通过在应用层或数据库层做排队的方式缓解，减少对同一行数据进行操作的并发度


### 高可用建设
- 架构阶段：考虑系统的可扩展性和容错性，避免单点，异地多机房部署
- 编码阶段：远程调用要设置合理的超时时间，要对无法预料的错误做默认处理。完备的log，tracing，metric。设计限流保护和异步处理。
- 测试阶段：测试用例
- 发布阶段：设计紧急回滚机制。
- 运行阶段：数据对账，自动降级，过载保护，实时监控报警
- 故障发生：及时止损，比如及时下架发生错误的商品。故障定位，快速恢复

保命三板斧：  
- 降级
- 限流
- 拒绝服务

### 业务方面
- 可以限制用户在x秒之内只能提交一次请求，
- 对同一个uid的请求进行计数和限速
- 下单流程和支付流程异步，以12306为例，下单成功后，系统占住库存，45分钟之内支付即可。
- 不同地域分时售票，
- 一旦点击，不管系统是否返回，按钮立刻置灰
- 只显示有/无车票，而不是显示具体票数目