#### 数组
- 两数之和：一个 map，key 是 nums[i]，value 是 i 一次循环，每次循环判断 target - nums[i] 的值在不在 map 的key里
- 三数之和：排序，三个指针，第一个是循环每个元素，第二三个，后半段的 left， right；循环(left < right), 计算 tartget 值，注意当等于时，将结果加入到结果集，还要循环对 left 和 right 进行去重；第一层循环末尾，要对第一个指针的值循环去重。
- 41.求数组缺失的第一个正数：用 map 存数组元素，循环数组，找不到相应顺序的正整数，就返回；如果要求时间复杂度是O(n),就把数组当成 map， hash 函数为 f(nums[i]) = nums[i] - 1

#### 链表
- 206：翻转链表：迭代 递归
- 141：判断有没有环：快慢指针, slow = slow.Next fast = fast.Next.Next
- 21.合并两个有序链表：递归
- 合并N个有序链表？先二分法把数组分成两两链表，然后同上，递归；其实也可以直接就两两合并。
- 19. 删除倒数第 n 个节点： 快慢指针，dummy 节点
- 找链表的中间节点：快慢指针
- offer 6. 从尾到头打印链表: 简单递归，引用数组


#### 队列、栈
- 20.有效括号：map{"(":")"...}, 循环数组放入栈中，map 中存在就是左括号，不存在就是右括号。遇到左括号直接入栈，遇到右括号，则出栈，看看在map中这个左括号是否对应正确的右括号
- 32.最长有效括号：只用一个栈就可以(非常巧妙)
  - 先 push 一个 -1
  - 循环字符串，遇到左括号，将 index 入栈
  - 遇到右括号，先 pop 一个出来，如果此时栈为空，则将 index 入栈占位，如果不为空，取 index - stack.pop 即可算出此时的length， 与max 做比较
- 逆波兰表达式求值：so easy
- 栈实现队列：两个栈，一个负责入队，一个负责出队
- 队列实现栈：一个队列，入栈时将新元素放在队首，之前的元素循环执行 queue.push(queue.pop)
- 设计循环双端队列/循环队列：循环队列判定空：head==tail；判定满：(tail+1)%n=head， 反向操作:(tail - 1 + n) % n
- 239. 滑动窗口的最大值：单调队列，注意正确删除单调队列中第一个元素


#### 递归

- 爬楼梯：记忆递归

#### 二分
- 求 x 的平方根，注意特殊的 0， 注意 mid = left + (right - left + 1)/2

#### 二叉树
- 反转二叉树：直接反转，递归左右子树
- 二叉树的最大深度：直接递归：return 1+max(func(root.Left), func(root.Right))
- 验证二叉搜索树：中序遍历，每个元素与 pre 比较，pre 初始化为最小值。在中序的位置，将root 值赋值给pre
- 112.给定二叉树和某个路径和，判断是否存在这样的根节点
